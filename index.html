<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta name="author", content="Louis Dionne">
    <title>Hana: Expressive metaprogramming</title>
    <link rel="stylesheet" href="css/reveal.min.css">
    <link rel="stylesheet" href="css/theme/default.css" id="theme">
    <link rel="stylesheet" href="lib/css/highlight/zenburn.css">
    <link rel="stylesheet" href="css/styles.css">
</head>

<body>
    <div class="reveal">
        <div class="slides">
            <section data-markdown=""
                     data-separator="^====+$"
                     data-vertical="^----+$"
                     data-notes="^Note:">
            <script type="text/template">

## Hana: Expressive metaprogramming
### Louis Dionne, CppCon 2014

====================

## Outline
- Motivation
- Concepts
- Examples
- Implementation techniques
- What I need from C++1z

==============================================================================

## Motivation: Why metaprogram?

<!--
TODO
also talk about motivations for Hana:
- lack of standard tools (integer_sequence is just lame)
- unification of type-level and value-level metaprogramming
- compile-time performance
- API more consistent, complete and general than Fusion's (my personal reason)
-->

==============================================================================

## Concepts

====================

## Foldable
Structures that can be linearized

----

## Tuple

```cpp
auto xs = tuple(1, '2', 3.3, std::string{"foo"});

assert(foldl(xs, std::string{"x"}, [](auto str, auto x) {
    return "(" + str + " + " +  to_s(x) + ")";
}) == "((((x + 1) + 2) + 3.3) + foo)");

assert(unpack(xs, [](int a, char b, double c, std::string d) {
    return to_s(a) + " " + to_s(b) + " " + to_s(c) + " " + d;
}) == "1 2 3.3 foo");

assert(count(xs, [](auto x) {
    return std::is_floating_point<decltype(x)>{};
}) == 1);
```

----

## Maybe

```cpp
assert(unpack(nothing, []() { return 0; }) == 0);
assert(unpack(just('x'), [](auto x) { return x; }) == 'x');

assert(sum(just(1)) == 1);
assert(sum(nothing) == 0);

assert(length(nothing) == 0);
assert(length(just(nullptr)) == 1);
```

====================

## Iterable
Structures that can be linearized, one element at a time

----

## Tuple

```cpp
auto xs = tuple(1, '2', 3.3, std::string{"foo"});

assert(head(xs) == 1);

assert(last(xs) == "foo");

assert(at_c<2>(xs) == 3.3);

assert(drop_until(xs, [](auto x) {
    return std::is_floating_point<decltype(x)>{};
}) == tuple(3.3, "foo"));
```

----

## Range

```cpp
auto r = range_c<int, 10, 20>;

assert((tail(r) == range_c<int, 11, 20>));

assert((drop_c<3>(r) == range_c<int, 13, 20>));

using namespace literals;
assert((drop_while(r, _ < 15_c) == range_c<int, 15, 20>));
```

====================

## Searchable
Structures associating keys to values

----

## Tuple

```cpp
auto xs = tuple(1, '2', 3.3, std::string{"foo"});

assert(find(xs, [](auto x) {
    return std::is_floating_point<decltype(x)>{};
}) == just(3.3));

assert(subset(tuple('2', "foo"), xs));

assert(any(xs, [](auto x) {
    return std::is_floating_point<decltype(x)>{};
}));

assert(3.3 ^in^ xs); // infix application :-)
```

----

## Map

```cpp
auto xs = map(
    pair(type<float>, 4),
    pair(int_<1>, std::string{"foo"})
);

assert(lookup(xs, type<float>) == just(4));
assert(lookup(xs, type<char>) == nothing);

assert(elem(xs, int_<1>));
```

====================

## List
Structures isomorphic to `std::tuple`

```cpp
auto xs = tuple(1, '2', 3.3, std::string{"foo"});

assert(xs == concat(tuple(1, '2'), tuple(3.3, "foo")));

assert(reverse(xs) == tuple("foo", 3.3, '2', 1));

assert((slice_c<1, 3>(xs) == tuple('2', 3.3)));

assert(take_until(xs, [](auto x) {
    return std::is_floating_point<decltype(x)>{};
}) == tuple(1, '2'));
```

====================

## Functor
Structures that can be mapped over

----

## Tuple

```cpp
auto xs = tuple(1, 3.3, std::string{"foo"});

assert(fmap(xs, [](auto x) {
    return x + x;
}) == tuple(2, 6.6, "foofoo"));

assert(adjust(xs,
    [](auto x) { return std::is_floating_point<decltype(x)>{}; },
    [](auto x) { return x + x; }
) == tuple(1, 6.6, "foo"));
```

----

## Maybe

```cpp
assert(replace(just(1.3),
    [](auto x) { return std::is_floating_point<decltype(x)>{}; },
    'x'
) == just('x'));

assert(fill(just(1.3), 'x') == just('x'));
assert(fill(nothing, 'x') == nothing);
```

====================

## Comparable
Objects that can be compared for equality

```cpp
// Any two Lists
assert(equal(tuple(1, '2', 3.3), std::make_tuple(1, '2', 3.3)));

// Maybes
assert(equal(just(1), just(1)));
assert(not_equal(just(1), nothing));

// EqualityComparable types
assert(equal(std::string{"foo"}, std::string{"foo"}));

// and about everything else provided by Hana
assert(equal(set(1, '2', 3.3), set(3.3, 1, '2')));
```

====================

## Orderable
Objects admitting a strict weak ordering

```cpp
// IntegralConstants
assert(int_<3> < int_<5>);
assert((
    std::integral_constant<long, 10>{} >=
    std::integral_constant<unsigned, 3>{}
));

// LessThanComparable types
assert(less(1, 3));
assert(greater(std::string{"foo"}, std::string{"bar"}));

// More will be provided when I get the time :-)
```

====================

## Monoid, Group, Ring, IntegralDomain
Consistent numeric hierarchy

```cpp
// Monoid
assert(zero<int> == 0);
assert(zero<Integral> == int_<0>);
assert(int_<3> + int_<5> == int_<8>);

// Group
assert(int_<3> - int_<7> == int_<-4>);
assert(-int_<3> == int_<-3>);

// Ring
assert(one<long> == 1l);
assert(one<Integral> == int_<1>);
assert(int_<2> * int_<4> == int_<8>);

// IntegralDomain
assert(int_<6> % int_<3> == int_<0>);
assert(int_<6> / int_<3> == int_<2>);
```

====================

## There's more
Applicative, Monad, Traversable, etc..

==============================================================================

## Examples

<!-- TODO -->

==============================================================================

## Implementation techniques

====================

## Tuple

```cpp
template <typename ...T>
/* constexpr */ decltype(auto) make_storage(T&& ...t) {
    return [t...](auto&& f) -> decltype(auto) {
        return std::forward<decltype(f)>(f)(t...);
    };
}

template <typename ...T>
struct tuple {
    using Storage = decltype(make_storage(std::declval<T>()...));
    Storage storage;

    template <typename ...U>
    /* constexpr */ explicit tuple(U&& ...u)
        : storage(make_storage(std::forward<U>(u)...))
    { };
};
```

----

## Time
![](code/benchmark/plots/benchmark.make_tuple.time.png)

----

## Memory usage
![](code/benchmark/plots/benchmark.make_tuple.memusg.png)

====================

## Random access

```cpp
struct eat { template <typename ...X> constexpr eat(X&& ...) { } };

template <std::size_t n, typename = std::make_index_sequence<n>>
struct get_impl;

template <std::size_t n, std::size_t ...ignore>
struct get_impl<n, std::index_sequence<ignore...>> {
    template <typename Nth, typename ...Rest>
    constexpr decltype(auto) operator()
    (decltype(ignore, eat{})..., Nth&& nth, Rest&& ...) const
    { return std::forward<Nth>(nth); }
};

template <std::size_t n, typename Tuple>
/* constexpr */ decltype(auto) get(Tuple&& ts) {
    return std::forward<Tuple>(ts).unpack_into(get_impl<n>{});
}
```

----

## Time
![](code/benchmark/plots/benchmark.get.time.png)

----

## Memory usage
![](code/benchmark/plots/benchmark.get.memusg.png)

====================

## Function mapping

```cpp
template <typename Tuple, typename F>
/* constexpr */ decltype(auto) transform(Tuple&& ts, F&& f) {
    return std::forward<Tuple>(ts).unpack_into(
        [f(std::forward<F>(f))](auto&& ...ts) -> decltype(auto) {
            return make_tuple(f(std::forward<decltype(ts)>(ts))...);
        }
    );
}
```

----

## Time
![](code/benchmark/plots/benchmark.transform.time.png)

----

## Memory usage
![](code/benchmark/plots/benchmark.transform.memusg.png)

====================

## Unpacking

```cpp
template <typename F, typename Tuple>
/* constexpr */ decltype(auto) apply(F&& f, Tuple&& ts) {
    return std::forward<Tuple>(ts).unpack_into(std::forward<F>(f));
}
```

----

## Time
![](code/benchmark/plots/benchmark.apply.time.png)

----

## Memory usage
![](code/benchmark/plots/benchmark.apply.memusg.png)

==============================================================================

## What I need from C++1z

<!--
TODO:
- constexpr lambdas
- Lambdas in unevaluated contexts, but I _really_ don't care about
    1. Deep SFINAE (if I understood well).
    2. Lambdas in symbols with external linkage.
-->

====================

# Thank you

<span class="fragment fade-in" data-fragment-index="1">
http://ldionne.com <br>
http://github.com/ldionne
</span>

            </script>
            </section>
        </div>
    </div>


    <script src="lib/js/head.min.js"></script>
    <script src="js/reveal.min.js"></script>
    <script>
        Reveal.initialize({
            slideNumber: true,

            dependencies: [
                { src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
                { src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
                { src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
                { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
                { src: 'plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } },
                { src: 'plugin/math/math.js', async: true },
                { src: 'plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } }
            ]
        });
    </script>
</body>

</html>