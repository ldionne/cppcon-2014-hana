<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta name="author", content="Louis Dionne">
    <title>Hana: Expressive metaprogramming</title>
    <link rel="stylesheet" href="css/reveal.min.css">
    <link rel="stylesheet" href="css/theme/default.css" id="theme">
    <link rel="stylesheet" href="lib/css/highlight/zenburn.css">
    <link rel="stylesheet" href="css/styles.css">
</head>

<body>
    <div class="reveal">
        <div class="slides">
            <section data-markdown=""
                     data-separator="^====+$"
                     data-vertical="^----+$"
                     data-notes="^Note:">
            <script type="text/template">

## Hana: Expressive metaprogramming
### Louis Dionne, CppCon 2014

====================

## Outline
- Why metaprogram?
- Hana's building blocks
- Type/value unification
- Implementation techniques
- Case studies
- What I need from C++1z

<!-- TODO: reduce this; list is too long -->

==============================================================================

## Why metaprogram?

====================

### Loop unrolling

Given a function `f`, we want
```cpp
f();
f();
...
f();
```
to be expanded at compile-time

====================

### Expression templates

We build a tree out of a C++ expression

```cpp
Matrix a = ...;
Matrix b = ...;

auto sum = a + b;  // returns a lazy expression; nothing computed yet
```

----

... and then perform domain-specific optimizations at compile-time by
modifying that tree.

```cpp
int i = sum[3][5]; // only computes a[3][5] + b[3][5]
```

----

### Good luck implementing that from scratch

====================

### Type computations

TODO: Show a typical use case

====================

### There's more

- Compile-time task ordering/parallelization
- Dimensional analysis
- etc...

====================

### Granted, it's mostly for library writers

====================

## What's the problem?

----

### The standard lacks proper tools

<ul>
    <li>`std::integer_sequence` is too low level</li> <!-- .element: class="fragment" -->
    <li>`std::tuple` compiles slowly</li> <!-- .element: class="fragment" -->
    <li>No high-level algorithms on `std::tuple`s</li> <!-- .element: class="fragment" -->
    <li>No standard way to do type-level computations</li> <!-- .element: class="fragment" -->
</ul>

====================

## I need a solution

----

## Hana

<ul>
    <li>Expressive and very complete interface</li> <!-- .element: class="fragment" -->
    <li>Better compile-time performance</li> <!-- .element: class="fragment" -->
    <li>Unifies type-level and value-level metaprogramming</li> <!-- .element: class="fragment" -->
</ul>

==============================================================================

## Hana's building blocks

====================

### Foldable
Structures that can be linearized

----

### Tuple

```cpp
auto xs = tuple(1, '2', 3.3, std::string{"foo"});

assert(foldl(xs, std::string{"x"}, [](auto str, auto x) {
    return "(" + str + " + " +  to_s(x) + ")";
}) == "((((x + 1) + 2) + 3.3) + foo)");

assert(unpack(xs, [](int a, char b, double c, std::string d) {
    return to_s(a) + " " + to_s(b) + " " + to_s(c) + " " + d;
}) == "1 2 3.3 foo");

assert(count(xs, [](auto x) {
    return std::is_floating_point<decltype(x)>{};
}) == 1);
```

----

### Maybe

```cpp
assert(unpack(nothing, []() { return 0; }) == 0);
assert(unpack(just('x'), [](auto x) { return x; }) == 'x');

assert(sum(just(1)) == 1);
assert(sum(nothing) == 0);

assert(length(nothing) == 0);
assert(length(just(nullptr)) == 1);
```

====================

### Iterable
Structures that can be linearized, one element at a time

----

### Tuple

```cpp
auto xs = tuple(1, '2', 3.3, std::string{"foo"});

assert(head(xs) == 1);

assert(last(xs) == "foo");

assert(at_c<2>(xs) == 3.3);

assert(drop_until(xs, [](auto x) {
    return std::is_floating_point<decltype(x)>{};
}) == tuple(3.3, "foo"));
```

----

### Range

```cpp
auto r = range_c<int, 10, 20>;

assert((tail(r) == range_c<int, 11, 20>));

assert((drop_c<3>(r) == range_c<int, 13, 20>));

using namespace literals;
assert((drop_while(r, _ < 15_c) == range_c<int, 15, 20>));
```

====================

### Searchable
Structures associating keys to values

----

### Tuple

```cpp
auto xs = tuple(1, '2', 3.3, std::string{"foo"});

assert(find(xs, [](auto x) {
    return std::is_floating_point<decltype(x)>{};
}) == just(3.3));

assert(subset(tuple('2', "foo"), xs));

assert(any(xs, [](auto x) {
    return std::is_floating_point<decltype(x)>{};
}));

assert(3.3 ^in^ xs); // infix application :-)
```

----

### Map

```cpp
auto xs = map(
    pair(type<float>, 4),
    pair(int_<1>, std::string{"foo"})
);

assert(lookup(xs, type<float>) == just(4));
assert(lookup(xs, type<char>) == nothing);

assert(elem(xs, int_<1>));
```

====================

### List
Structures isomorphic to `std::tuple`

```cpp
auto xs = tuple(1, '2', 3.3, std::string{"foo"});

assert(xs == concat(tuple(1, '2'), tuple(3.3, "foo")));

assert(reverse(xs) == tuple("foo", 3.3, '2', 1));

assert((slice_c<1, 3>(xs) == tuple('2', 3.3)));

assert(take_until(xs, [](auto x) {
    return std::is_floating_point<decltype(x)>{};
}) == tuple(1, '2'));
```

====================

### Functor
Structures that can be mapped over

----

### Tuple

```cpp
auto xs = tuple(1, 3.3, std::string{"foo"});

assert(fmap(xs, [](auto x) {
    return x + x;
}) == tuple(2, 6.6, "foofoo"));

assert(adjust(xs,
    [](auto x) { return std::is_floating_point<decltype(x)>{}; },
    [](auto x) { return x + x; }
) == tuple(1, 6.6, "foo"));
```

----

### Maybe

```cpp
assert(replace(just(1.3),
    [](auto x) { return std::is_floating_point<decltype(x)>{}; },
    'x'
) == just('x'));

assert(fill(just(1.3), 'x') == just('x'));
assert(fill(nothing, 'x') == nothing);
```

====================

### Comparable
Objects that can be compared for equality

```cpp
// Any two Lists
assert(equal(tuple(1, '2', 3.3), std::make_tuple(1, '2', 3.3)));

// Maybes
assert(equal(just(1), just(1)));
assert(not_equal(just(1), nothing));

// EqualityComparable types
assert(equal(std::string{"foo"}, std::string{"foo"}));

// and about everything else provided by Hana
assert(equal(set(1, '2', 3.3), set(3.3, 1, '2')));
```

====================

### Orderable
Objects admitting a strict weak ordering

```cpp
// IntegralConstants
assert(int_<3> < int_<5>);
assert((
    std::integral_constant<long, 10>{} >=
    std::integral_constant<unsigned, 3>{}
));

// LessThanComparable types
assert(less(1, 3));
assert(greater(std::string{"foo"}, std::string{"bar"}));

// More will be provided when I get the time :-)
```

====================

### Monoid, Group, Ring, Integral Domain
Consistent numeric hierarchy

```cpp
// Monoid
assert(zero<int> == 0);
assert(zero<Integral> == int_<0>);
assert(int_<3> + int_<5> == int_<8>);

// Group
assert(int_<3> - int_<7> == int_<-4>);
assert(-int_<3> == int_<-3>);

// Ring
assert(one<long> == 1l);
assert(one<Integral> == int_<1>);
assert(int_<2> * int_<4> == int_<8>);

// IntegralDomain
assert(int_<6> % int_<3> == int_<0>);
assert(int_<6> / int_<3> == int_<2>);
```

====================

### There's more
Applicative, Monad, Traversable, etc..

==============================================================================

## Type/value unification

====================

### It's actually pretty simple

TODO: Explain how it's done.

==============================================================================

## Case studies

====================

### Loop unrolling revisited

```cpp
auto unroll = [](auto n, auto&& f) {
    boost::hana::for_each(boost::hana::range(boost::hana::int_<0>, n),
        [f(std::forward<decltype(f)>(f))](auto i) { f(); }
    );
};

void f(); // can't be inlined

int main() {
    unroll(boost::hana::int_<10>, f);
}
```

----

### Generated asm with -O3

```asm
_main:
    # <snip>
    callq   __Z1fv
    callq   __Z1fv
    callq   __Z1fv
    callq   __Z1fv
    callq   __Z1fv
    callq   __Z1fv
    callq   __Z1fv
    callq   __Z1fv
    callq   __Z1fv
    callq   __Z1fv
    xorl    %eax, %eax
    popq    %rbp
    retq
```

====================

### Expression templates revisited

TODO

====================

### Type computations revisited

TODO

====================

### Heterogeneous linear algebra

TODO

==============================================================================

## Implementation techniques

====================

`std::tuple`

```cpp
template <typename ...T>
/* constexpr */ decltype(auto) make_storage(T ...t) {
    return [t...](auto&& f) -> decltype(auto) {
        return std::forward<decltype(f)>(f)(t...);
    };
}

template <typename ...T>
struct tuple {
    using Storage = decltype(make_storage(std::declval<T>()...));
    Storage unpack_into;

    template <typename ...U>
    /* constexpr */ explicit tuple(U&& ...u)
        : unpack_into(make_storage(std::forward<U>(u)...))
    { };
};
```

Note:
We should move-capture with `t{std::move(t)}...` in `make_storage`, but this
fails on both Clang and GCC.

----

### Time
![](code/benchmark/plots/benchmark.make_tuple.time.png)

----

### Memory usage
![](code/benchmark/plots/benchmark.make_tuple.memusg.png)

====================

`std::get`

```cpp
struct eat { template <typename ...X> constexpr eat(X&& ...) { } };

template <std::size_t n, typename = std::make_index_sequence<n>>
struct get_impl;

template <std::size_t n, std::size_t ...ignore>
struct get_impl<n, std::index_sequence<ignore...>> {
    template <typename Nth, typename ...Rest>
    constexpr decltype(auto) operator()
    (decltype(ignore, eat{})..., Nth&& nth, Rest&& ...) const
    { return std::forward<Nth>(nth); }
};

template <std::size_t n, typename Tuple>
/* constexpr */ decltype(auto) get(Tuple&& ts) {
    return std::forward<Tuple>(ts).unpack_into(get_impl<n>{});
}
```

----

### Time (biased)
![](code/benchmark/plots/benchmark.get.time.png)

----

### Memory usage (biased)
![](code/benchmark/plots/benchmark.get.memusg.png)

----

### Time (unbiased)
![](code/benchmark/plots/benchmark.get.unbiased.time.png)

----

### Memory usage (unbiased)
![](code/benchmark/plots/benchmark.get.unbiased.memusg.png)

====================

`std::tuple_cat`

```cpp
template <typename Xs, typename Ys>
/* constexpr */ auto tuple_cat(Xs xs, Ys ys) {
    return xs.unpack_into([=](auto ...x) {
        return ys.unpack_into([=](auto ...y) {
            return make_tuple(x..., y...);
        });
    });
}
```

Note:
Perfect forwarding left out for readability, and also because it is very
tricky to implement.

----

### Time (biased)
![](code/benchmark/plots/benchmark.tuple_cat.time.png)

----

### Memory usage (biased)
![](code/benchmark/plots/benchmark.tuple_cat.memusg.png)

----

### Time (unbiased)
![](code/benchmark/plots/benchmark.tuple_cat.unbiased.time.png)

----

### Memory usage (unbiased)
![](code/benchmark/plots/benchmark.tuple_cat.unbiased.memusg.png)

====================

The proposed `std::apply`

```cpp
template <typename F, typename Tuple>
/* constexpr */ decltype(auto) apply(F&& f, Tuple&& ts) {
    return std::forward<Tuple>(ts).unpack_into(std::forward<F>(f));
}
```

----

### Time (biased)
![](code/benchmark/plots/benchmark.apply.time.png)

----

### Memory usage (biased)
![](code/benchmark/plots/benchmark.apply.memusg.png)

----

### Time (unbiased)
![](code/benchmark/plots/benchmark.apply.unbiased.time.png)

----

### Memory usage (unbiased)
![](code/benchmark/plots/benchmark.apply.unbiased.memusg.png)

====================

An hypothetical `std::tuple_transform`

```cpp
template <typename Tuple, typename F>
/* constexpr */ decltype(auto) tuple_transform(Tuple&& ts, F&& f) {
    return std::forward<Tuple>(ts).unpack_into(
        [f(std::forward<F>(f))](auto&& ...ts) -> decltype(auto) {
            return make_tuple(f(std::forward<decltype(ts)>(ts))...);
        }
    );
}
```

----

### Time (biased)
![](code/benchmark/plots/benchmark.tuple_transform.time.png)

----

### Memory usage (biased)
![](code/benchmark/plots/benchmark.tuple_transform.memusg.png)

----

### Time (unbiased)
![](code/benchmark/plots/benchmark.tuple_transform.unbiased.time.png)

----

### Memory usage (unbiased)
![](code/benchmark/plots/benchmark.tuple_transform.unbiased.memusg.png)

==============================================================================

## What I need from C++1z

====================

### Constexpr lambdas

```cpp
constexpr auto inc = [](auto x) {
    return x + 1;
};

static_assert(inc(1) == 2, "");
```

====================

### Lambdas in some unevaluated contexts

```cpp
using T = decltype(
    head(
        fmap(tuple(type<int>, type<char>, type<float>), [](auto t) {
            return type<typename decltype(t)::type**>;
        })
    )
)::type;
```

Note:
Specifically, explain that I don't care about
1. Deep SFINAE (if I understood well that this is an issue).
2. Lambdas in symbols with external linkage.

====================

### Better handling of parameter packs in captures

```cpp
auto f = [](auto ...x) {
    auto g = [y(x)...] {
        // y should be a parameter pack
    };
};
```

====================

# Thank you

<span class="fragment fade-in" data-fragment-index="1">
http://ldionne.com <br>
http://github.com/ldionne
</span>

            </script>
            </section>
        </div>
    </div>


    <script src="lib/js/head.min.js"></script>
    <script src="js/reveal.min.js"></script>
    <script>
        Reveal.initialize({
            slideNumber: true,

            dependencies: [
                { src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
                { src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
                { src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
                { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
                { src: 'plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } },
                { src: 'plugin/math/math.js', async: true },
                { src: 'plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } }
            ]
        });
    </script>
</body>

</html>